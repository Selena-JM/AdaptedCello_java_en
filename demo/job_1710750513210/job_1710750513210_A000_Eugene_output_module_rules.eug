PartType output;
PartType scar;
PartType promoter;

output RFP(.SEQUENCE("CTGAAGTGGTCGTGATCTGAAACTCGATCACCTGATGAGCTCAAGGCAGAGCGAAACCACCTCTACAAATAATTTTGTTTAATACTAGAGTCACACAGGAAAGTACTAGATGGCTTCCTCCGAAGACGTTATCAAAGAGTTCATGCGTTTCAAAGTTCGTATGGAAGGTTCCGTTAACGGTCACGAGTTCGAAATCGAAGGTGAAGGTGAAGGTCGTCCGTACGAAGGTACCCAGACCGCTAAACTGAAAGTTACCAAAGGTGGTCCGCTGCCGTTCGCTTGGGACATCCTGTCCCCGCAGTTCCAGTACGGTTCCAAAGCTTACGTTAAACACCCGGCTGACATCCCGGACTACCTGAAACTGTCCTTCCCGGAAGGTTTCAAATGGGAACGTGTTATGAACTTCGAAGACGGTGGTGTTGTTACCGTTACCCAGGACTCCTCCCTGCAAGACGGTGAGTTCATCTACAAAGTTAAACTGCGTGGTACCAACTTCCCGTCCGACGGTCCGGTTATGCAGAAAAAAACCATGGGTTGGGAAGCTTCCACCGAACGTATGTACCCGGAAGACGGTGCTCTGAAAGGTGAAATCAAAATGCGTCTGAAACTGAAAGACGGTGGTCACTACGACGCTGAAGTTAAAACCACCTACATGGCTAAAAAACCGGTTCAGCTGCCGGGTGCTTACAAAACCGACATCAAACTGGACATCACCTCCCACAACGAAGACTACACCATCGTTGAACAGTACGAACGTGCTGAAGGTCGTCACTCCACCGGTGCTTAATAACAGATAAAAAAAATCCTTAGCTTTCGCTAAGGATGATTTCT"));
promoter pPhlF(.SEQUENCE("CGACGTACGGTGGAAtctgattcgttaccaattgacATGATACGAAACGTACCGTATCGTTAAGGT"));
scar Cscar(.SEQUENCE("aatg"));
scar Escar(.SEQUENCE("gctt"));

Device RFP_device(
   promoter,
   RFP
);

Rule RFP_rules ( ON RFP_device:
   CONTAINS pPhlF AND 
   STARTSWITH pPhlF AND
   ALL_FORWARD
);


RFP_devices     = product(RFP_device);

Device gate_RFP();

Device circuit();

Rule allRules( ON circuit:
   gate_RFP     EXACTLY 1 AND 
   ALL_FORWARD AND 
   ALL_FORWARD AND 
   Escar        EXACTLY 1 AND 
   Cscar        EXACTLY 1 AND 
   FORWARD Escar AND 
   FORWARD Cscar AND 
   [0] EQUALS Escar AND 
   [2] EQUALS Cscar
);

Array allResults;

for(num i1=0;  i1<sizeof(RFP_devices);     i1=i1+1) {

gate_RFP     = RFP_devices[i1];

Device circuit(
   gate_RFP,
   Escar,
   Cscar
);

result = permute(circuit);

allResults = allResults + result;

}
